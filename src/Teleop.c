#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  none)
#pragma config(Sensor, S2,     ArmLimit,       sensorTouch)
#pragma config(Motor,  motorA,          SwagA,         tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorB,          SwagB,         tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C1_1,     Left,          tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     Right,         tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     Elevator,      tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     Arm,           tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C3_1,    Claw,                 tServoStandard)
#pragma config(Servo,  srvo_S1_C3_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.

#define SCALE .7 // Scale factor for the x axis of the steering joystick
#define FAST_POWER 100
#define SLOW_POWER 25
#define CLAW_CLOSED_POS 75
#define CLAW_OPENED_POS 15
#define ARM_MAX_POWER 20
#define ELEVATOR_POWER -35

short map (short in, float max, float newMax);

void initializeRobot()
{
  servo[Claw] = CLAW_OPEN_POS;
  return;
}

/* Single stick drive (left)
// Bottom right bumper (8) shifts speed (hold for slow/precision mode)
// Bottom left bumper (7) reverses robot drive direction
// Top right bumper (6) is for closing the claw
// Top left bumper (5) is for opening the claw
// Right stick vertical axis is raising and lowering the arm
// Button 1 toggles elevator
*/

task main()
{
  initializeRobot();

  float maxPower = FAST_POWER;
  bool elevatorButtonPressed = false;

  waitForStart();   // wait for start of tele-op phase
  getJoystickSettings(joystick);
  while (true)
  {
		//Claw Operations
		if (joy1Btn(5) == 1)
		{
			// fully close claw
			servo[Claw] = CLAW_CLOSE_POS;
		}
		else if (joy1Btn(6) == 1)
		{
			// open claw
			servo[Claw] = CLAW_OPEN_POS;
		}

		//Elevator toggle
		if (joy1Btn(1) == 1 && !elevatorButtonPressed)
		{
			if (motor[Elevator] == 0)
			{
				motor[Elevator] = ELEVATOR_POWER;
			}
			else
			{
				motor[Elevator] = 0;
			}
			elevatorButtonPressed = true;
		}
		else if (joy1Btn(1) == 0)
		{
			elevatorButtonPressed = false;
		}

		//Speed shifting
		if (joy1Btn(8) == 1)
		{
			// downshift to slow, precision mode
			maxPower = SLOW_POWER;
		}
		else
		{
			maxPower = FAST_POWER;
		}

		// Driving control only using the left joystick
		short y = map(joystick.joy1_y1, 127, maxPower);
		short x = map(joystick.joy1_x1, 127, maxPower);
		short left =  (y + (x * SCALE));
	 	short right = - (y - (x * SCALE));
	 	// holding down button 7 will reverse the direction of the drive
	 	if (joy1Btn(7) == 1) {
	 		left = -left;
	 		right = -right;
	 	}
	 	motor[Left] = left;
	 	motor[Right] = right;

	 	// Move arm using right joystick
	 	// negative because of our particular wiring polarity
		short arm = map(joystick.joy1_y2, 127, armMax);
		if (arm > 0) arm = arm + 15; // add power when moving up (more negative)
		if (SensorValue(ArmLimit) == 1 && arm > 0) {
			arm = 0;
		}
		motor[Arm] = -arm;

// Driving - tank drive control
//		motor[Left] = - map(joystick.joy1_y1, 127, maxPower);
//		motor[Right] = map(joystick.joy1_y2, 127, maxPower);

	 	getJoystickSettings(joystick);
  }

}

short map (short in, float max, float newMax)
{
	return (short)(((float)in / max) * newMax);
}
