#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  none)
#pragma config(Sensor, S2,     ArmLimitUp,     sensorTouch)
#pragma config(Sensor, S3,     ArmLimitDown,   sensorTouch)
#pragma config(Motor,  motorA,          SwagA,         tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorB,          SwagB,         tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C1_1,     Left,          tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     Right,         tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     Elevator,      tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     Arm,           tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C3_1,    Claw,                 tServoStandard)
#pragma config(Servo,  srvo_S1_C3_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.


/***********************************************************************
	Teleop program for Acton Roboticc Team #3938 in the challenge "Block Party"
	The robot has the following parts:
		Elevator - (tetrix motor) a converyor belt that carries blocks into the crates
		Arm - (tetrix motor) a mechanism that picks up blocks and places them in the Elevator
		Claw - (servo) part of the arm that grips the blocks
		ArmLimitUp - (touch sensor) stops the arm from rising too high
		ArmLimitDown - (touch sensor) stops the arm from falling too low.

	Controls:
		left joystick - left wheel
		right joystick - right wheel
		button 1 - toggle elevator motor
		button 4 - move arm up
		button 5 - close claw
		button 6 - open claw
		button 8 - speec shift toggler (fast/slow)

	@author Koushik Krishnan, Andrew Dai
************************************************************************/
#define SCALE .7 // Scale factor for the x axis of the steering joystick
#define FAST_POWER 100
#define SLOW_POWER 25
#define CLAW_CLOSE_POS 75
#define CLAW_OPEN_POS 15
#define ARM_MAX_POWER 20
#define ELEVATOR_POWER -35

short map (short in, float max, float newMax);

/*
	initialize robot to open the claw
*/
void initializeRobot()
{
  servo[Claw] = CLAW_OPEN_POS;
  return;
}


task main()
{
  initializeRobot();

  float maxPower = FAST_POWER;
  bool elevatorButtonPressed = false;

  waitForStart();   // wait for start of tele-op phase
  getJoystickSettings(joystick);
  while (true)
  {
		//Claw Operations
		if (joy1Btn(5) == 1)
		{
			// fully close claw
			servo[Claw] = CLAW_CLOSE_POS;
		}
		else if (joy1Btn(6) == 1)
		{
			// open claw
			servo[Claw] = CLAW_OPEN_POS;
		}

		//Elevator toggle
		if (joy1Btn(1) == 1 && !elevatorButtonPressed)
		{
			if (motor[Elevator] == 0)
			{
				motor[Elevator] = ELEVATOR_POWER;
			}
			else
			{
				motor[Elevator] = 0;
			}
			elevatorButtonPressed = true;
		}
		else if (joy1Btn(1) == 0)
		{
			elevatorButtonPressed = false;
		}

		//Speed shifting
		if (joy1Btn(8) == 1)
		{
			// downshift to slow, precision mode
			maxPower = SLOW_POWER;
		}
		else
		{
			maxPower = FAST_POWER;
		}

		// Controlling the movement of the arm.
		// Button 4 moves arm up until the upper touch sensor is triggered
		// Button 2 moves arm down until the lower touch sensor is triggered
		bool armUpBtnPressed = (joy1Btn(4) == 1 && joy1Btn(2) != 1);
		bool armDownBtnPressed = (joy1Btn(4) != 1 && joy1Btn(2) == 1);
		short arm = 0;
		if(armUpBtnPressed){
			arm = 35;
		}
		else if(armDownBtnPressed){
			arm = -20;
		}
		// control upward limit of the front arm. This makes sure the
		// arm does not go too high
		if (SensorValue(ArmLimitUp) == 1 && arm > 0) {
			arm = 0;
		}
		if(SensorValue(ArmLimitDown) == 1 && arm < 0){
			arm = 0;
		}
		motor[Arm] = -arm;

	// Driving - tank drive control
		motor[Left] = - map(joystick.joy1_y1, 127, maxPower);
		motor[Right] = map(joystick.joy1_y2, 127, maxPower);

	 	getJoystickSettings(joystick);
  }

}

short map (short in, float max, float newMax)
{
	return (short)(((float)in / max) * newMax);
}
