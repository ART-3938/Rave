#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  none)
#pragma config(Sensor, S2,     ArmLimit,       sensorTouch)
#pragma config(Motor,  motorA,          SwagA,         tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorB,          SwagB,         tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C1_1,     Left,          tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     Right,         tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     Elevator,      tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     Arm,           tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C3_1,    Claw,                 tServoStandard)
#pragma config(Servo,  srvo_S1_C3_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.

short map (short in, float max, float newMax);

void initializeRobot()
{
  // Place code here to sinitialize servos to starting positions.
  // Sensors are automatically configured and setup by ROBOTC. They may need a brief time to stabilize.

  return;
}

/* Single stick drive (left)
// Bottom right bumper (8) shifts speed (hold for slow/precision mode)
// Bottom left bumper (7) reverses robot drive direction
// Top right bumper (6) is for closing the claw
// Top left bumper (5) is for opening the claw
// Right stick vertical axis is raising and lowering the arm
// Button 1 toggles elevator
*/

task main()
{
  initializeRobot();

  float scale = .7;
  float fastPower = 100;
  float slowPower = 25;
  float maxPower = fastPower;

  bool clawMoving = false;
  short fastServoRate = 0;
  short normalServoRate = 30;
  short clawOpenPos = 75;
  short clawClosePos = 15;

  short armMax = 20;

  short elevatorOn = -35;
  bool elevatorButtonPressed = false;

  bool toggle = false;

  waitForStart();   // wait for start of tele-op phase
	getJoystickSettings(joystick);
  while (true)
  {
	 	//Claw Operations
		if (joy1Btn(5) == 1)
		{
			// fully open claw
			servoChangeRate[Claw] = fastServoRate;
			servoTarget[Claw] = clawOpenPos;
		}
		else if (joy1Btn(6) == 1)
		{
			// close claw
			servoChangeRate[Claw] = fastServoRate;
			servoTarget[Claw] = clawClosePos;
		}

		//Elevator toggle
		if (joy1Btn(1) == 1 && !elevatorButtonPressed)
		{
			if (motor[Elevator] == 0)
			{
				motor[Elevator] = elevatorOn;
			}
			else
			{
				motor[Elevator] = 0;
			}
			elevatorButtonPressed = true;
		}
		else if (joy1Btn(1) == 0)
		{
			elevatorButtonPressed = false;
		}

		//Speed shifting
		if (joy1Btn(8) == 1)
		{
			// downshift to slow, precision mode
			maxPower = slowPower;
		}
		else
		{
			maxPower = fastPower;
		}

		// Driving control only using the left joystick
	  short y = map(joystick.joy1_y1, 127, maxPower);
	  short x = map(joystick.joy1_x1, 127, maxPower);
	  short left =  - (y + (x * scale));
	 	short right = (y - (x * scale));
	 	// holding down button 7 will reverse the direction of the drive
	 	if (joy1Btn(7) == 1) {
	 		left = -left;
	 		right = -right;
	 	}
	 	motor[Left] = left;
	 	motor[Right] = right;

	 	// Move arm using right joystick
	 	// negative because of our particular wiring polarity
		short arm = map(joystick.joy1_y2, 127, armMax);
		if (arm > 0) arm = arm + 15; // add power when moving up (more negative)
		if (SensorValue(ArmLimit) == 1 && arm > 0) {
			arm = 0;
			servoTarget[Claw] = clawClosePos; //close is open CHANGE
		}
		motor[Arm] = -arm;

// Driving - tank drive control
//		motor[Left] = - map(joystick.joy1_y1, 127, maxPower);
//		motor[Right] = map(joystick.joy1_y2, 127, maxPower);

	 	getJoystickSettings(joystick);
  }

}

short map (short in, float max, float newMax)
{
	return (short)(((float)in / max) * newMax);
}
